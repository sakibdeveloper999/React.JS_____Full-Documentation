# useContext in React — Step-by-Step (what it is, how it works, when & how to use it)

**One-sentence summary:** `useContext` lets any component read values provided by a context `Provider` anywhere above it in the component tree — perfect for app-wide settings (theme, auth, locale) without prop-drilling.

---

## 1) What is Context & `useContext` (concept)

* **Context** is a way to share values (objects, primitives, functions) between components without passing props through every intermediate component.
* `useContext(ContextObject)` is a React Hook that subscribes the component to that context and returns the current value.
* A **Context** has two main parts:

  * `const MyContext = React.createContext(defaultValue)`
  * `<MyContext.Provider value={...}>` — wraps subtree to provide the value.

---

## 2) When to use `useContext` (use cases)

Use context when you need the same data in many places across the component tree:

* Theme (light/dark, colors)
* Authentication state (currentUser, token, login/logout)
* Locale / i18n settings
* App settings or feature flags
* UI state shared across non-related branches (modals, toasts)
  Avoid context for ephemeral local state that belongs to one component.

---

## 3) Basic step-by-step example — Theme toggler

### Step A — create the context

```jsx
// theme-context.js
import React from 'react';
export const ThemeContext = React.createContext({
  theme: 'light',         // default
  toggleTheme: () => {}   // default stub
});
```

### Step B — provide the context near app root

```jsx
// App.jsx
import React, { useState } from 'react';
import { ThemeContext } from './theme-context';
import Page from './Page';

export default function App(){
  const [theme, setTheme] = useState('light');
  const toggleTheme = () => setTheme(t => (t === 'light' ? 'dark' : 'light'));

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      <Page />
    </ThemeContext.Provider>
  );
}
```

### Step C — consume with `useContext`

```jsx
// Header.jsx
import React, { useContext } from 'react';
import { ThemeContext } from './theme-context';

export default function Header(){
  const { theme, toggleTheme } = useContext(ThemeContext);
  return (
    <header className={theme === 'dark' ? 'bg-gray-900' : 'bg-white'}>
      <button onClick={toggleTheme}>Toggle theme</button>
    </header>
  );
}
```

Any component under `ThemeContext.Provider` can call `useContext(ThemeContext)` to read/update the theme.

---

## 4) Step-by-step explanation of what happens at runtime

1. `createContext(default)` creates a context object with an internal `Provider` and `Consumer`.
2. `<Provider value={...}>` sets the context value for its subtree.
3. When a component calls `useContext(MyContext)`, React finds the nearest `Provider` above it and returns its `value`.
4. When the `Provider`'s `value` changes (reference equality), React re-renders all consuming components that used `useContext` for that context.

---

## 5) Important implementation details & best practices

* **Provider placement:** Put Providers at a logical high level (App or feature root). But avoid a single giant Provider that stores lots of unrelated state — split contexts by concern (theme, auth, UI).
* **Value stability:** To avoid unnecessary re-renders, memoize value when it’s an object:

  ```jsx
  const value = useMemo(() => ({ theme, toggleTheme }), [theme, toggleTheme]);
  ```

  or keep updater functions stable with `useCallback`.
* **Avoid putting frequently-changing things in context** (e.g., every keystroke) — that triggers many re-renders across consumers.
* **Default value usage:** Default in `createContext` is used only when a component consumes context without a Provider above it (rare in production).
* **Context vs props:** Prefer props for local, single-branch state. Use context for cross-cutting concerns.

---

## 6) Performance considerations

* Context causes re-render of all consuming components when provider `value` changes (by referential equality). To reduce work:

  * Split context into smaller contexts (one for theme, one for auth).
  * Memoize `value` object so it changes only when its contents change.
  * Use derived state inside provider and pass stable functions (`useCallback`).
  * For very high-frequency updates, consider other strategies (local state + subscriptions, external store).

---

## 7) Patterns & advanced usage

* **Multiple contexts:** Compose providers:

  ```jsx
  <AuthProvider>
    <ThemeProvider>
      <App />
    </ThemeProvider>
  </AuthProvider>
  ```
* **Custom hook wrapper:** Provide a nicer API and safety checks:

  ```jsx
  const AuthContext = createContext(null);

  export function useAuth(){
    const ctx = useContext(AuthContext);
    if (!ctx) throw new Error('useAuth must be used within AuthProvider');
    return ctx;
  }
  ```
* **Context with reducer:** Good for complex state logic:

  ```jsx
  const [state, dispatch] = useReducer(reducer, initialState);
  <Context.Provider value={{ state, dispatch }} />
  ```
* **Lazy initialization:** Use `createContext()` without a default or with `null` if you always wrap provider; add runtime checks.

---

## 8) Testing tips

* When testing a component that uses context, wrap it in the Provider in the test:

  ```jsx
  render(
    <ThemeContext.Provider value={{ theme: 'dark', toggleTheme: jest.fn() }}>
      <Header />
    </ThemeContext.Provider>
  );
  ```
* Or use your `Provider` component to mount with the same app logic.

---

## 9) Alternatives & when to choose them

* **Props** — if only parent→child needed.
* **Local state** — for isolated component state.
* **Redux / Zustand / Jotai** — if you need:

  * predictable central store
  * time-travel/debugging
  * middleware, devtools
    But for small-to-medium shared concerns, Context + `useReducer` or custom hooks is often enough.
* **Event emitter / subscription** — for highly-performant cross-component updates without re-rendering everything.

---

## 10) Common pitfalls

* Passing a new object inline to `value` causes all consumers to re-render every time the parent renders.
* Consuming context outside a Provider returns the default value — which can hide bugs. Prefer `null` default and throw if missing.
* Overusing context for everything => tight coupling and large re-render trees.
* Mutating value inside context (mutating objects) — always treat context value as immutable.

---

## 11) Mini real-world use cases (quick list)

* Theme toggler (dark/light)
* Auth: `{ user, login, logout }`
* Cart: `{ items, addItem, removeItem }` in small e-commerce
* Localization: `{ locale, setLocale, t }`
* Modal manager / toast notifications

---

## 12) Checklist before using `useContext`

* Is this data needed by many components across different branches? → Yes → use context.
* Is the data changing extremely frequently (per keystroke)? → Maybe avoid context.
* Can I split concerns into multiple contexts? → Yes — do it.
* Will provider `value` be memoized/stable? → Ensure it.

---

## 13) Example: Auth context (full)

```jsx
// auth-context.js
import React, { createContext, useCallback, useContext, useState } from 'react';
const AuthContext = createContext(null);

export function AuthProvider({ children }){
  const [user, setUser] = useState(null);

  const login = useCallback(async (creds) => {
    const fetchedUser = await fakeApiLogin(creds);
    setUser(fetchedUser);
  }, []);

  const logout = useCallback(() => setUser(null), []);

  const value = React.useMemo(() => ({ user, login, logout }), [user, login, logout]);

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth(){
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used within an AuthProvider');
  return ctx;
}
```

Use `useAuth()` in any child component to access `user`, `login`, `logout`.

---

## 14) Quick cheat-sheet (short)

* Create: `const C = createContext(default)`
* Provide: `<C.Provider value={...}>`
* Consume: `const v = useContext(C)`
* Memoize provider value, split contexts, and don’t overuse.

---
